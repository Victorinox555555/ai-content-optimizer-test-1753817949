"""
Authentication module for Test-auth_setup
Generated by QWEN-GPT-AGI autonomous SaaS factory
"""

import hashlib
import secrets
import sqlite3
from datetime import datetime, timedelta
from functools import wraps
from flask import session, request, jsonify, redirect, url_for

class AuthManager:
    def __init__(self, db_path="users.db"):
        self.db_path = db_path
        self.init_db()
    
    def init_db(self):
        """Initialize user database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                email TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                salt TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                is_active BOOLEAN DEFAULT 1,
                subscription_status TEXT DEFAULT 'free'
            )
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS sessions (
                id TEXT PRIMARY KEY,
                user_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                expires_at TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        """)
        conn.commit()
        conn.close()
    
    def hash_password(self, password: str, salt: str | None = None) -> tuple:
        """Hash password with salt"""
        if salt is None:
            salt = secrets.token_hex(32)
        password_hash = hashlib.pbkdf2_hmac('sha256', 
                                          password.encode('utf-8'), 
                                          salt.encode('utf-8'), 
                                          100000)
        return password_hash.hex(), salt
    
    def create_user(self, email: str, password: str) -> dict:
        """Create new user account"""
        try:
            password_hash, salt = self.hash_password(password)
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO users (email, password_hash, salt)
                VALUES (?, ?, ?)
            """, (email, password_hash, salt))
            user_id = cursor.lastrowid
            conn.commit()
            conn.close()
            
            return {"success": True, "user_id": user_id, "message": "Account created successfully"}
        except sqlite3.IntegrityError:
            return {"success": False, "message": "Email already exists"}
        except Exception as e:
            return {"success": False, "message": f"Error creating account: {str(e)}"}
    
    def authenticate_user(self, email: str, password: str) -> dict:
        """Authenticate user login"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, password_hash, salt, is_active 
                FROM users WHERE email = ?
            """, (email,))
            user = cursor.fetchone()
            conn.close()
            
            if not user:
                return {"success": False, "message": "Invalid email or password"}
            
            user_id, stored_hash, salt, is_active = user
            
            if not is_active:
                return {"success": False, "message": "Account is deactivated"}
            
            password_hash, _ = self.hash_password(password, salt)
            
            if password_hash == stored_hash:
                session_id = self.create_session(user_id)
                return {
                    "success": True, 
                    "user_id": user_id, 
                    "session_id": session_id,
                    "message": "Login successful"
                }
            else:
                return {"success": False, "message": "Invalid email or password"}
                
        except Exception as e:
            return {"success": False, "message": f"Authentication error: {str(e)}"}
    
    def create_session(self, user_id: int) -> str:
        """Create user session"""
        session_id = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(days=30)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO sessions (id, user_id, expires_at)
            VALUES (?, ?, ?)
        """, (session_id, user_id, expires_at))
        conn.commit()
        conn.close()
        
        return session_id
    
    def validate_session(self, session_id: str) -> dict:
        """Validate user session"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT s.user_id, u.email, s.expires_at
                FROM sessions s
                JOIN users u ON s.user_id = u.id
                WHERE s.id = ? AND s.expires_at > datetime('now')
            """, (session_id,))
            session = cursor.fetchone()
            conn.close()
            
            if session:
                user_id, email, expires_at = session
                return {
                    "valid": True,
                    "user_id": user_id,
                    "email": email,
                    "expires_at": expires_at
                }
            else:
                return {"valid": False, "message": "Invalid or expired session"}
                
        except Exception as e:
            return {"valid": False, "message": f"Session validation error: {str(e)}"}

auth_manager = AuthManager()

def login_required(f):
    """Decorator to require authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        session_id = session.get('session_id') or request.headers.get('Authorization')
        if not session_id:
            return jsonify({"error": "Authentication required"}), 401
        
        session_data = auth_manager.validate_session(session_id)
        if not session_data.get('valid'):
            return jsonify({"error": "Invalid session"}), 401
        
        request.current_user = session_data
        return f(*args, **kwargs)
    return decorated_function

def admin_required(f):
    """Decorator to require admin privileges"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not hasattr(request, 'current_user'):
            return jsonify({"error": "Authentication required"}), 401
        return f(*args, **kwargs)
    return decorated_function
